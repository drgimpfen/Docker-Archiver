# Notify Discord on Release (sends release title + notes to a Discord webhook)
# Requires repository secret: DISCORD_WEBHOOK_URL
# Optional: uses GITHUB_TOKEN to fetch latest release on manual dispatch

name: Notify Discord on Release

on:
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      release_tag:
        description: 'Release tag to notify (required when triggering manually, e.g., v0.8.0).'
        required: true

jobs:
  notify-discord:
    runs-on: ubuntu-latest
    env:
      WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
      # When triggered by a release event these will be populated from the event
      RELEASE_NAME: ${{ github.event.release.name }}
      RELEASE_TAG: ${{ github.event.release.tag_name }}
      RELEASE_BODY: ${{ github.event.release.body }}
      RELEASE_URL: ${{ github.event.release.html_url }}
    steps:
      - name: Populate release info (when run manually)
        if: github.event_name == 'workflow_dispatch'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          INPUT_TAG: ${{ github.event.inputs.release_tag }}
          # Optional PAT fallback in case GITHUB_TOKEN cannot access releases (create secret RELEASE_FETCH_TOKEN with a PAT having 'repo' scope)
          RELEASE_FETCH_TOKEN: ${{ secrets.RELEASE_FETCH_TOKEN }}
        run: |-
          set -e
          TAG="$INPUT_TAG"
          if [ -z "$TAG" ]; then
            echo "ERROR: 'release_tag' input is required when running manually. Provide a tag like 'v0.8.0'."
            exit 1
          fi

          # Choose auth header: prefer a provided PAT (RELEASE_FETCH_TOKEN), otherwise use GITHUB_TOKEN
          if [ -n "$RELEASE_FETCH_TOKEN" ]; then
            AUTH_HEADER="Authorization: token $RELEASE_FETCH_TOKEN"
          else
            AUTH_HEADER="Authorization: Bearer $GITHUB_TOKEN"
          fi

          echo "Fetching release for tag: $TAG"
          curl -s -H "Accept: application/vnd.github+json" -H "$AUTH_HEADER" "https://api.github.com/repos/${{ github.repository }}/releases/tags/$TAG" -o /tmp/release.json

          python - <<'PY'
          import json, os
          try:
              d=json.load(open('/tmp/release.json'))
          except Exception as e:
              print('Failed to parse release JSON:', e)
              print(open('/tmp/release.json').read())
              raise
          name = d.get('name') or d.get('tag_name') or ''
          tag = d.get('tag_name') or ''
          body = d.get('body') or ''
          url = d.get('html_url') or ''
          # Write variables to GITHUB_ENV using multiline EOF syntax to support newlines
          with open(os.environ['GITHUB_ENV'],'a') as f:
              f.write("RELEASE_NAME<<'EOF'\n")
              f.write(name + "\n")
              f.write("EOF\n")
              f.write("RELEASE_TAG<<'EOF'\n")
              f.write(tag + "\n")
              f.write("EOF\n")
              f.write("RELEASE_BODY<<'EOF'\n")
              f.write(body + "\n")
              f.write("EOF\n")
              f.write("RELEASE_URL<<'EOF'\n")
              f.write(url + "\n")
              f.write("EOF\n")
          PY

      - name: Send Discord notification
        run: |-
          if [ -z "${WEBHOOK_URL}" ]; then
            echo "DISCORD_WEBHOOK_URL not set, skipping notification";
            exit 0;
          fi

          python - <<'PY'
          import os, json, urllib.request, datetime

          webhook_url = os.environ['WEBHOOK_URL']
          name = os.environ.get('RELEASE_NAME') or os.environ.get('RELEASE_TAG') or 'Release'
          tag = os.environ.get('RELEASE_TAG') or ''
          body = os.environ.get('RELEASE_BODY') or ''
          url = os.environ.get('RELEASE_URL') or ''

          # Build embed
          max_desc = 3000
          description = body.strip() if body.strip() else f"Release {tag}" if tag else 'No description provided.'
          if len(description) > max_desc:
              description = description[:max_desc-3] + '...'

          title = f"{name} ({tag})" if tag else name

          embed = {
              'title': title,
              'description': description,
              'url': url or None,
              'timestamp': datetime.datetime.utcnow().isoformat() + 'Z',
              'color': 3447003
          }

          payload = json.dumps({'embeds': [embed]}).encode('utf-8')
          req = urllib.request.Request(webhook_url, data=payload, headers={'Content-Type': 'application/json'})
          try:
              with urllib.request.urlopen(req) as resp:
                  print('Discord embed sent, HTTP', resp.status)
          except Exception as e:
              print('Failed to send Discord embed:', e)
              raise
          PY
